<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vista de Cuadrícula</title>
    <style>
        .grid {
            display: grid;
            grid-template-columns: repeat(20, 40px); /* 20 columnas */
            grid-template-rows: repeat(15, 40px); /* 15 filas */
            gap: 1px;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid black;
            background-color: lightgray;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        .valueG, .valueH, .valueTotal {
            font-size: 10px;
            position: absolute;
        }
        .valueG {
            top: 2px;
            left: 2px;
        }
        .valueH {
            top: 2px;
            right: 2px;
        }
        .valueTotal {
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
        }
        .cell.partida {
            background-color: red;
        }
        .cell.destino {
            background-color: blue;
        }
        .cell.adyacente {
            background-color: yellow;
        }
        .cell.obstaculo {
            background-color: black;
        }
        .cell.cerrada {
            background-color: lightsteelblue; /* Color gris azulado */
        }
        .cell.camino {
            background-color: green; /* Color del camino más corto */
        }
    </style>
</head>
<body>

    <h1>Vista de Cuadrícula</h1>

    <button id="toggle-mode">Modo: Partida</button>
    <button id="validate-selection">Validar Partida y Destino</button>
    <button id="calculate-adjacent">Iniciar Búsqueda</button>
    <button id="toggle-obstaculo">Modo: Obstáculo</button>

    <div class="grid" id="grid"></div>

    <script>
        const rows = 15;
        const cols = 20;

        const grid = document.getElementById('grid');
        let selectedPartida = null;
        let selectedDestino = null;
        let isPartidaMode = true;
        let isObstaculoMode = false;

        const toggleButton = document.getElementById('toggle-mode');
        const toggleObstaculoButton = document.getElementById('toggle-obstaculo');
        const calculateButton = document.getElementById('calculate-adjacent');

        let celdasAbiertas = [];
        let celdasCerradas = [];

        // Crear la cuadricula inicial
        function crearCuadricula() {
            grid.innerHTML = '';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.setAttribute('data-row', row);
                    cell.setAttribute('data-col', col);
                    cell.addEventListener('click', cellClicked);
                    grid.appendChild(cell);
                }
            }
        }

        // Al hacer clic en el botón "Toggle Mode"
        toggleButton.addEventListener('click', function() {
            isPartidaMode = !isPartidaMode;
            isObstaculoMode = false;
            toggleButton.textContent = isPartidaMode ? "Modo: Partida" : "Modo: Destino";
            toggleObstaculoButton.textContent = "Modo: Obstáculo";
        });

        // Al hacer clic en el botón "Modo Obstáculo"
        toggleObstaculoButton.addEventListener('click', function() {
            isObstaculoMode = !isObstaculoMode;
            isPartidaMode = false;
            toggleButton.textContent = "Modo: Partida";
            toggleObstaculoButton.textContent = isObstaculoMode ? "Modo: Obstáculo Activo" : "Modo: Obstáculo";
        });

        // Función para manejar el clic en las celdas
        function cellClicked(event) {
            const clickedCell = event.target;
            const row = parseInt(clickedCell.getAttribute('data-row'));
            const col = parseInt(clickedCell.getAttribute('data-col'));

            if (isObstaculoMode) {
                clickedCell.style.backgroundColor = '#000000';
                clickedCell.classList.add('obstaculo');
            } else if (isPartidaMode) {
                if (selectedPartida) {
                    selectedPartida.classList.remove('partida');
                }
                selectedPartida = clickedCell;
                selectedPartida.classList.add('partida');
            } else {
                if (selectedDestino) {
                    selectedDestino.classList.remove('destino');
                }
                selectedDestino = clickedCell;
                selectedDestino.classList.add('destino');
            }
        }

        // Función para calcular celdas adyacentes
        calculateButton.addEventListener('click', function() {
            if (!selectedPartida || !selectedDestino) {
                alert("Debe seleccionar un punto de partida y un punto de destino.");
                return;
            }

            iniciarBusqueda();
        });

        function iniciarBusqueda() {
            // Limpiar las listas abiertas y cerradas
            celdasAbiertas = [];
            celdasCerradas = [];

            // Agregar la celda de partida a la lista abierta
            celdasAbiertas.push({
                cell: selectedPartida,
                g: 0, // El costo desde el punto de partida hasta el mismo punto es 0
                h: calcularHeuristica(selectedPartida),
                f: calcularHeuristica(selectedPartida), // Al inicio, f = h
                parent: null // La celda de partida no tiene celda padre
            });

            // Marcar las celdas adyacentes de la celda de partida
            const { row, col } = obtenerCoordenadas(selectedPartida);
            marcarAdyacentes(row, col, 0);

            // Iniciar el bucle de búsqueda
            realizarBusqueda();
        }

        function realizarBusqueda() {
            if (celdasAbiertas.length === 0) {
                alert("No se ha encontrado una ruta.");
                return;
            }

            // Elegir la celda con el menor valor de f en la lista abierta
            const celdaActual = celdasAbiertas.reduce((prev, curr) => (prev.f < curr.f ? prev : curr));

            // Mover la celda actual a la lista cerrada
            celdasCerradas.push(celdaActual.cell);
            celdaActual.cell.classList.remove('adyacente');
            celdaActual.cell.classList.add('cerrada'); // Pintamos la celda de color gris azulado
            celdasAbiertas = celdasAbiertas.filter(celda => celda !== celdaActual);

            // Si llegamos al destino, trazamos el camino
            if (celdaActual.cell === selectedDestino) {
                trazarCamino(celdaActual);
                alert("¡Ruta encontrada!");
                return;
            }

            const { row: actualRow, col: actualCol } = obtenerCoordenadas(celdaActual.cell);

            // Coordenadas de las celdas adyacentes (8 direcciones)
            const adyacentes = [
                { row: actualRow - 1, col: actualCol - 1, diagonal: true },
                { row: actualRow - 1, col: actualCol, diagonal: false },
                { row: actualRow - 1, col: actualCol + 1, diagonal: true },
                { row: actualRow, col: actualCol - 1, diagonal: false },
                { row: actualRow, col: actualCol + 1, diagonal: false },
                { row: actualRow + 1, col: actualCol - 1, diagonal: true },
                { row: actualRow + 1, col: actualCol, diagonal: false },
                { row: actualRow + 1, col: actualCol + 1, diagonal: true }
            ];

            // Evaluar las celdas adyacentes
            adyacentes.forEach(adyacente => {
                const cell = grid.querySelector(`[data-row="${adyacente.row}"][data-col="${adyacente.col}"]`);

                // Ignorar celdas que son obstáculos o que ya están en la lista cerrada
                if (!cell || cell.classList.contains('obstaculo') || celdasCerradas.includes(cell)) {
                    return;
                }

                const g = celdaActual.g + (adyacente.diagonal ? 14 : 10);
                const h = calcularHeuristica(cell);
                const f = g + h;

                // Verificar si la celda ya está en la lista abierta
                const celdaExistente = celdasAbiertas.find(celda => celda.cell === cell);

                if (celdaExistente) {
                    // Si la celda ya está en la lista abierta, actualizar si encontramos un mejor camino
                    if (g < celdaExistente.g) {
                        celdaExistente.g = g;
                        celdaExistente.f = f;
                        celdaExistente.parent = celdaActual;
                        updateCellDisplay(cell, g, h, f);
                    }
                } else {
                    // Si no está en la lista abierta, agregarla
                    celdasAbiertas.push({
                        cell: cell,
                        g: g,
                        h: h,
                        f: f,
                        parent: celdaActual
                    });

                    cell.classList.add('adyacente');
                    updateCellDisplay(cell, g, h, f);
                }
            });

            // Continuar el ciclo si no hemos llegado al destino
            setTimeout(realizarBusqueda, 500); // Pausa para visualizar el proceso
        }

        function trazarCamino(celdaActual) {
            let currentCell = celdaActual;
            while (currentCell) {
                currentCell.cell.classList.add('camino');
                currentCell = currentCell.parent;
            }
        }

        function obtenerCoordenadas(cell) {
            return {
                row: parseInt(cell.getAttribute('data-row')),
                col: parseInt(cell.getAttribute('data-col'))
            };
        }

        function calcularHeuristica(cell) {
            const { row: destinoRow, col: destinoCol } = obtenerCoordenadas(selectedDestino);
            const { row: cellRow, col: cellCol } = obtenerCoordenadas(cell);
            return (Math.abs(destinoRow - cellRow) + Math.abs(destinoCol - cellCol)) * 10; // Distancia Manhattan
        }

        function updateCellDisplay(cell, g, h, f) {
            cell.innerHTML = '';

            const gLabel = document.createElement('div');
            gLabel.classList.add('valueG');
            gLabel.textContent = g;
            cell.appendChild(gLabel);

            const hLabel = document.createElement('div');
            hLabel.classList.add('valueH');
            hLabel.textContent = h;
            cell.appendChild(hLabel);

            const fLabel = document.createElement('div');
            fLabel.classList.add('valueTotal');
            fLabel.textContent = f;
            cell.appendChild(fLabel);
        }

        // Función para marcar las celdas adyacentes a la celda seleccionada
        function marcarAdyacentes(row, col) {
            const adyacentes = [
                { row: row - 1, col: col - 1, diagonal: true },
                { row: row - 1, col: col, diagonal: false },
                { row: row - 1, col: col + 1, diagonal: true },
                { row: row, col: col - 1, diagonal: false },
                { row: row, col: col + 1, diagonal: false },
                { row: row + 1, col: col - 1, diagonal: true },
                { row: row + 1, col: col, diagonal: false },
                { row: row + 1, col: col + 1, diagonal: true }
            ];

            adyacentes.forEach(adyacente => {
                const cell = grid.querySelector(`[data-row="${adyacente.row}"][data-col="${adyacente.col}"]`);
                if (cell && !cell.classList.contains('obstaculo')) {
                    cell.classList.add('adyacente');
                }
            });
        }

        // Crear la cuadrícula al cargar la página
        crearCuadricula();
    </script>
</body>
</html>
